stop();// BANNER EVENT HOOKS			function on_mouse_exit_stage()		{										}				function close_banner()		{			trace('close banner');		}		function onFlipStart(page, eventMessage) 		{		}				function onFlipEnd(page, eventMessage) 		{			if(page>0)			{				hide_left_nav = false;				hide_right_nav = false;			}						if(page === maxpage)			{				hide_right_nav = true;			}						banner_is_ready = true;					}		function mouse_detected_over_banner()		{		}///--------------------------close_btn.onRelease = close_banner_global.pfroot = thisXMLfn = _root.xml_data ? _root.xml_data : "http://static.kedscollective.com/banners/quarter_2/xml/data.xml";_global.mcnt = 0;	//countergpage = 0;			//gotoPage Nogflip = false;		//gotoPage flipgdir = 0;			//goto direction...gskip = false;		//skip pages	***gtarget = 0;		//target when skippingaflip = false;		//auto flipflip = false;		//pageflipflipOff = false;	//terminateflipflipOK = false;		//good flippgmaskh = ph;preflip = false;	//corner flip statusctear = false;		//actual page statustear = false;teard = 0;overbutton = false;removedPages = new Array();	//list of removed pages!mpx = 0, mpy = 0;	//mousepos at clicksx = sy = 0;		//startpoint when flippingx = 0;				//mouse x,yy = 0;ax = 0;				//auto x,yay = 0;acnt = 0;aadd = 0;aamp = 0;op0 = op1 = op2 = op3 = op4 = op5 = 0;np0 = np1 = np2 = np3 = np4 = np5 = 0;pagesOffsetX = 0;	//Used for center single page animationpagesTargetX = 0;CenterAnimation = false;CenterAnimActive = false;CenterAnimDir = 0;AM = Math.PI/180;directlink = _root.directlink;	//linking to a page from html embed levelif(directlink == undefined) directlink = -1;var first_load = true;var banner_is_ready = false;var user_detected_over_banners = true;hide_left_nav = true;hide_right_nav = false;var user_detected_over_banner = false;nav_left._visible = false;var mouse_dx:Number=_xmouse;var mouse_dy:Number=_ymouse;var mouseSpeed:Number=1;function checkPosition(Void):Void {	if(_xmouse<mouseSpeed || _xmouse>(Stage.width-mouseSpeed) || _ymouse<mouseSpeed  || _ymouse>(Stage.height-mouseSpeed)) 	{		on_mouse_exit_stage();	} 	else 	{		mouse_detected_over_banner();			}}checkPosition(Void);var mouse_move_listener:Object = new Object();																					mouse_move_listener.onMouseMove = function():Void {																					mouse_dx = Math.abs(mouse_dx-_xmouse);	mouse_dy = Math.abs(mouse_dy-_ymouse);		mouseSpeed = mouse_dx > mouse_dy ? mouse_dx  : mouse_dy;	mouseSpeed +=1;		checkPosition(Void);		mouse_dx=_xmouse;	mouse_dy=_ymouse;}Mouse.addListener(mouse_move_listener);//initializing pages... -------------------------------		function reset(maxpage) {						pageNumber = new Array();			for(var i=0;i<=(maxpage+1);i++) pageNumber[i] = i;		}				mousecontroll = new Object();		//initializing mouse click handler --------------------		mousecontroll.onMouseDown = function() {				if(flip && !aflip) 				{					flipOK = false;						if(sx<0 && pages._xmouse>0) flipOK = true;					if(sx>0 && pages._xmouse<0) flipOK = true;					flipOff = true;					flip = false;				} 				else if((flipOff || aflip || !canflip) && !preflip) 				{								} 				else if(!preflip) 				{					var oox = ox;					var ooy = oy;					var osx = sx;					var osy = sy;				} 				else 				{						onFlipStart(page,"PAGECLICK");	//Event Handler ****					flip = true;					flipOff = false;					tear = false;			//not tearing yet...					aflip = preflip = false;					mpx = pages._xmouse, mpy = pages._ymouse;					oef();				}		}		mousecontroll.onMouseUp = function() 		{				if(flip && !tear) 				{					if(Math.abs(pages._xmouse-mpx)<afa || preflip) 					{						flip = false;						preflip = false;						check_to_animate_corner();					} 					else if(!preflip) 					{						flipOK = false;							if(sx<0 && pages._xmouse>0) flipOK = true;						if(sx>0 && pages._xmouse<0) flipOK = true;						flipOff = true;						flip = false;					} 				} 		}				function pagehittest() {			var x=pages._xmouse;			var y=pages._ymouse;			var pmh = ph/2;						var xadd = 0;			var tadd = 0;			var badd = 0;								if(y<=(pmh+badd) && y>=-(pmh+tadd) && x<=(pw+xadd) && x>=-(pw+xadd)) {	//ha a megadott intervallumban klikkelunk, akkor lapozhatunk				return true;			}			return false;		}				function hittest() {	//hittest at mouse clicks, if click is over the book -> determining turning direction ------------------------------------			var x=pages._xmouse;			var y=pages._ymouse;			var pmh = ph/2;						var xadd = 0;			var tadd = 0;			var badd = 0;			pgmaskh = ph;								if(y<=(pmh+badd) && y>=-(pmh+tadd) && x<=(pw+xadd) && x>=-(pw+xadd)) 			{					if(x>pw) x = pw;				if(x<-pw) x = - pw;				if(y>pmh) y = pmh;				if(y<-pmh) y = - pmh;				var r = Math.sqrt(x*x+y*y);				var a = Math.asin(y/r);				var y = Math.tan(a)*pw;				oy = sy = y;				r0 = Math.sqrt((sy+ph/2)*(sy+ph/2)+pw*pw);				r1 = Math.sqrt((ph/2-sy)*(ph/2-sy)+pw*pw);								if(x<-(pw-clickarea) && page>gminpage) {		//page>0) {	//>-----> flip backward					setPages(page-2,page-1,page,page+1);					offs = -pw;					fmask._x = pw;					ctear = p[pageNumber[page]].tear;					return -1;				}								if(x>(pw-clickarea) && page<gmaxpage-1) {	//<-----< flip forward					setPages(page,page+2,page+1,page+3);					offs = 0;					fmask._x = 0;					ctear = p[pageNumber[page+1]].tear;					return 1;				}			} else return 0;	//wrong click		}		function corner() {			if(!user_detected_over_banners)			{				return false;			}			var x = Math.abs(pages._xmouse);			var y = Math.abs(pages._ymouse);			if(x>(pw-afa) && x<pw && y>(ph/2-afa) && y<(ph/2) && pages._ymouse > 25 && Math.abs(pages._xmouse) > 200 ) {				return true;			}				return false;		}				function check_to_hide_nav()		{			if(page === 0)			{				hide_left_nav = true;			}						if(hide_left_nav)			{				nav_left._visible = false;							}			else			{				nav_left._visible = true;										}						if(hide_right_nav)			{				nav_right._visible = false;							}			else if(page != maxpage)			{				nav_right._visible = true;										}					}		function check_which_nav_to_hide()		{			if(pages._xmouse <= -200)			{				hide_left_nav = true;							}			else if(pages._xmouse >= 200)			{								hide_right_nav = true;			}		}				function oef() {									check_to_hide_nav();						_global.mcnt++;	//main counter incrase (need for some page effect);									if(!flip  && corner()) 			{					check_which_nav_to_hide();								preflip = true;				fmask._x = pw;				if(!check_to_animate_corner()) preflip = false;			}									if(preflip && !corner()) 			{				hide_left_nav = false;				hide_right_nav = false;						preflip = false;				preflipend = true;				flip = false;				flipOK = false;				flipOff = true;			}						getm();					if(aflip && !preflip) 			{					y = (ay += (sy-ay)/(gflip? gs: ps ));				acnt += aadd;				ax -= aadd;				if(Math.abs(acnt)>pw) {					flipOK = true;					flipOff = true;					flip = false;					aflip = false;				}			}					if(flip) 			{							//page turning is in progress...				x = (ox += (x-ox)/(gflip? gs: ps ));				y = (oy += (y-oy)/(gflip? gs: ps ));				calc(x,y);						//positioning pages and shadows			}						if(flipOff) 			{						//terminating page turning effect... (comlplete turning... dropped on the other side)				if(flipOK) 				{										x = (ox += (-sx-ox)/(gflip? gs: es ));					y = (oy += (sy-oy)/(gflip? gs: es ));					calc(x,y);									if(x/-sx > 0.99) 					{															//we are done with turning, so stop all turning issue...						flip = false;						flipOK = flipOff = false;								page += (sx<0)? -2: 2;	//and tourning pages at pagenumber level...						flipend();						if(gskip) page = gtarget;						setPages(page,0,0,page+1);						if(!tear) onFlipEnd(page, "SUCCESS");	//Event handler ****						tear = false;												if(gpage>0 && !gskip) 						{			//gotoflip active -> is there another flipping left?							gpage--;							check_to_animate_corner();												} else gflip = gskip = false;					}				} 				else 				{						//terminating page turning effect... (incomlplete turning... dropped on the dragged side)					x = (ox += (sx-ox)/3);					y = (oy += (sy-oy)/3);					calc(x,y);										if(x/sx > 0.99) 					{									//we are done with turning, so stop all turning issue...						flip = false;						flipOff = false;						aflip = false;						if(!preflipend) onFlipEnd(page, "FAULT");		//Event handler ****						preflipend = false;						flipend();						setPages(page,0,0,page+1);	//no change at pagenumbers..					}				}			}		}						function calc(x,y) {	//positioning pages and shadows by x,y reference points while flipping -------------------------------						 fgrad._visible = true;	//normal flipping needs projected shine/shadow effect						//normal flipping process---------------------------------------------------------------------						//calculating position/rotation/masking of the flipping page 			var rr0 = Math.sqrt((y+ph/2)*(y+ph/2)+x*x);			var rr1 = Math.sqrt((ph/2-y)*(ph/2-y)+x*x);			if((rr0>r0 || rr1>r1) && !tear) {	// we can tear off pages now:)												// so reference points must be recalculated!				if(y<sy) {											var a = Math.asin((ph/2-y)/rr1);					y = (ph/2-Math.sin(a)*r1);					x = (x<0)? -Math.cos(a)*r1: Math.cos(a)*r1;					if(y>sy) {						if((sx*x)>0) y = sy, x = sx;						else y = sy, x = -sx;					}					if((rr1-r1)>tlimit && ctear) {						teard = -5;						tear = true;						tox = ox = x;						toy = oy = y;					//	startsnd(3);					}				} else {											var a = Math.asin((y+ph/2)/rr0);					y = Math.sin(a)*r0-ph/2;					x = (x<0)? -Math.cos(a)*r0: Math.cos(a)*r0;					if(y<sy) {						if((sx*x)>0) y = sy, x = sx;						else y = sy, x = -sx;					}					if((rr0-r0)>tlimit && ctear) {						teard = 5;						tear = true;						tox = ox = x;						toy = oy = y;					//startsnd(3);					}				}			}			if((sx<0 && (x-sx)<10) || (sx>0 && (sx-x)<10)) {				if(sx<0) x = -pw+10;				if(sx>0) x = pw-10;			} 			//calculating flipping process			p3shadow._visible = pgrad._visible = !tear;			pp2._visible = pp3._visible = true;			//equation of the line			var vx = x-sx;			var vy = y-sy;			var a1 = vy/vx;			var a2 = -vy/vx;						cx = sx+(vx/2);			cy = sy+(vy/2);			//trigonometriai 			//calculating rotation of the page, and the masks			var r = Math.sqrt((sx-x)*(sx-x)+(sy-y)*(sy-y));			var a = Math.asin((sy-y)/r);			if(sx<0) a = -a;				ad = a/AM; 	//in degree			pageN._rotation = ad*2;			//r = Math.sqrt((sx-x)*(sx-x)+(sy-y)*(sy-y));			rl = (pw*2);			var scl = (r/rl/2)*pw;			if(sx>0) { 											//flip forward				pages.mask0._xscale = pages.mask1._xscale = 100;				nx = cx-Math.tan(a)*(ph/2-cy);				ny = ph/2;				if(nx>pw) {					nx = pw;					ny = cy+Math.tan(Math.PI/2+a)*(pw-cx);				}				pageN.pf._x = -(pw-nx);				fgrad._xscale = scl;				pgrad._xscale = -scl;				p3shadow._xscale = scl;			} else { 											//flip backward				pages.mask0._xscale = pages.mask1._xscale = -100;				nx = cx-Math.tan(a)*(ph/2-cy);				ny = ph/2;				if(nx<-pw) {					nx = -pw;					ny = cy+Math.tan(Math.PI/2+a)*(-pw-cx);				}				pageN.pf._x = -(pw-(pw+nx));				fgrad._xscale = -scl;				pgrad._xscale = scl;				p3shadow._xscale = -scl;			}			pages.mask0._x = pages.mask1._x = cx;			pages.mask0._y = pages.mask1._y = cy;			pages.mask0._rotation = pages.mask1._rotation = ad;			pageN.pf._y = -ny;			pageN._x = nx+offs;			pageN._y = ny;			fgrad._x = cx;			fgrad._y = cy;			fgrad._rotation = ad;			var av = (r>(rl-50))? 100-(r-(rl-50))*2: 100;			fgrad._alpha = av;			p3shadow._x = cx;			p3shadow._y = cy;			p3shadow._rotation = ad;			p3shadow._alpha = av;			pgrad._x = cx;			pgrad._y = cy;			pgrad._rotation = ad+180;			pgrad._alpha = av;						fmask.page._x = pageN._x;			fmask.page._y = pageN._y;			fmask.page.pf._x = pageN.pf._x;			fmask.page.pf._y = pageN.pf._y;			fmask.page._rotation = pageN._rotation;		}				function setPages(p1,p2,p3,p4) {	//set page visibilities						//new pages to display				np1 = p1;				np2 = p2;				np3 = p3;				np4 = p4;												if(np1<0) np1=0;	//available pages				if(np2<0) np2=0;				if(np3<0) np3=0;				if(np4<0) np4=0;				if(np4>maxpage) np4=0;								var noFlip = (np2==0&&np3==0);	//are there any active flipping?											if(CenterSinglePage) {						//set up center animation								if(np2==0 && np3==0) {									CenterAnimation = false;			//** no animation									if(np1==0 || np4==0) {				//place to center										if(np1==0) pagesOffsetX = -pw/2;										else pagesOffsetX = pw/2;									} else pagesOffsetX = 0;									setPagesX();								}								if(np1==0 || np4==0) {									if(np2 && np3) {					//** center animation enabled										CenterAnimation = true;										if(np1==0) CenterAnimDir = -1										else CenterAnimDir = 1;									}								}							}							//disable old pages				p[pageNumber[op1]].item._visible = false;				p[pageNumber[op1]].page.reset(false,false);				p[pageNumber[op2]].item._visible = false;				p[pageNumber[op2]].page.reset(false,false);				p[pageNumber[op3]].item._visible = false;				p[pageNumber[op3]].page.reset(false,false);				p[pageNumber[op4]].item._visible = false;				p[pageNumber[op4]].page.reset(false,false);							p[pageNumber[np1]].item._visible = true;				p[pageNumber[np2]].item._visible = true;				p[pageNumber[np3]].item._visible = true;				p[pageNumber[np4]].item._visible = true;								p[pageNumber[np1]].item.swapDepths(11);				p[pageNumber[np2]].item.swapDepths(23);				p[pageNumber[np3]].item.swapDepths(20);				p[pageNumber[np4]].item.swapDepths(10);								p[pageNumber[np1]].page.reset(true,false,noFlip);				p[pageNumber[np2]].page.reset(true,false);				p[pageNumber[np3]].page.reset(true,false);				p[pageNumber[np4]].page.reset(true,false,noFlip);								var poff = new Array();								for(var i=1;i<5;i++) 				{					poff[i] = this["np"+i];				}								for(var i=1;i<5;i++) 				{					var present = false;										for(var j=1;j<5;j++) 					{						if(this["op"+i] == poff[j]) present = true;					}										if(!present) 					{						p[pageNumber[this["op"+i]]].page.reset(false,false);					}				}								op1 = np1;				op2 = np2;				op3 = np3;				op4 = np4;											pgrad.swapDepths(19);				pgmask._height = pgmaskh;				p3shadow.swapDepths(21);												pageN.pf._x = 0;				pageN.pf._y = 0;				pageN._x = -pw;				pageN._y = 0;				pageN._rotation = 0;								pageN = p[pageNumber[np2]].item.page;	//eval("pages.flip.p2.page");				pageO = p[pageNumber[np3]].item;		//eval("pages.flip.p3");				pp2 = p[pageNumber[np2]].item;				pp3 = pageO;				hp2 = pp2.page.pf.sph;					//hardpage				hp3 = pp3.page.pf.sph;												ctrl.setpager();								if(pagesready) startPageLoading();	//page loadeing on demand								if(first_load){							cover._visible = false;						flip_to_first_page_on_banner_load();				}		}				function flip_to_first_page_on_banner_load(){					first_load = false;					gotoPage(2,true);		}				function resetPages() {			setPages(page,0,0,page+1);		}					function check_to_animate_corner(calcpos) 		{								//start auto flip!						if(calcpos==undefined) calcpos=true;						if(!aflip && !flip && !flipOff && canflip && calcpos) 			{	//only when all conditions fits our needs...				if(calcpos) 				{					acnt = 0					aamp = Math.random()*(ph/2)-(ph/4);					var x= gflip? (gdir*pw)/2: ((pages._xmouse<0)? -pw/2: pw/2);					var y = Math.random()*(ph/2)-(ph/4);					if(y<0) y-=(ph/8);					if(y>0) y+=(ph/8);					var pmh = ph/2;					var r = Math.sqrt(x*x+y*y);					var a = Math.asin(y/r);					var yy = Math.tan(a)*pw;					if(y>ph/2) y = ph/2;					if(y<-ph/2) y = - ph/2;					oy = sy = yy;					ax = (pages._xmouse<0)? -pw/2: pw/2;					var l = ((ph/2)-y);					ay = y+((Math.random()*2*l)-l)/2;				//page turnig style randomizing				}								pgmaskh = ph;	//set the shadow height 					hit = 0;								// animate left corner				if(x<0 && page>1) 				{					ctear = p[pageNumber[page]].tear;										if(gskip) setPages(gtarget,gtarget+1,page,page+1);										else setPages(page-2,page-1,page,page+1);										offs = -pw					fmask._x = pw;					hit = -1;				}								// animate left corner				if(x>0 && page<gmaxpage) 				{					ctear = p[pageNumber[page+1]].tear;						if(gskip) setPages(page,gtarget,page+1,gtarget+1);						else setPages(page,page+2,page+1,page+3);					offs = 0					fmask._x = 0;					hit = 1;				}												if(hit) 				{								flip = true;					flipOff = false;					ox = sx = hit*pw;					pp2.setMask(pages.mask0);					pp3.setMask(pages.mask1);					aadd = hit*(pw/10);	//hit*(pw/(gflip? 5:10 ));			//check_to_animate_corner takes 10 frames to be done!!!					aflip = true;					if(preflip) {						oy = sy = (pages._ymouse<0)? -(ph/2): (ph/2);					}					r0 = Math.sqrt((sy+ph/2)*(sy+ph/2)+pw*pw);					r1 = Math.sqrt((ph/2-sy)*(ph/2-sy)+pw*pw);					oef();					return true;				}			} 			else			{				 return false;			}		}				function getm() {	//get x,y reference points depending of turning style: manual/auto			if(aflip && !preflip) {				x = ax;				y = ay;			} else {				x = pages._xmouse;				y = pages._ymouse;			}		}		function gotoPage(i,skip) 		{					gskip = (skip==undefined)? false: skip;	//skip pages						if(i<0) return false;			var p = int(page/2);		//current page			var d = int(i/2);			//target page			if(p!=d && canflip && !gflip) {		//target!=current page				if(p<d) {						//go forward					gdir = 1;					gpage = d-p-1;				} else {						//go backward					gdir = -1					gpage = p-d-1;				}				gflip = true;				if(gskip) gtarget = d*2, gpage = 0;				onFlipStart(page,"GOTOPAGE");	//Event Handler ****				check_to_animate_corner();			} 			else			{				 gskip = false;			}		}				function testFileName(fn) {		//check if the page is embedded or not			var test = new Object();			var temp = fn.split(":");			if(temp[0]=="embedded") {				test.embedded = true;				test.name = temp[1];			} else {				test.embedded = false;				test.name = fn;			}			return test;		}		function setPagesX() {		}		function setShadows() {			var maxl = Math.sqrt(ph*ph+pw*pw);						fmask = pages.attachMovie("fmask","fmask",10000);				fmask.page.pf._width = pw;			fmask.page.pf._height = ph;			fgrad = pages.attachMovie("fgrad","fgrad",10001);			fgrad._yscale = 3*maxl;			fgrad.setMask(fmask);						pgmask = pages.attachMovie("pgmask","pgmask",10002);			pgmask._width = 2*pw;			pgmask._height = pgmaskh = ph;			pgrad = pages.attachMovie("pgrad","pgrad",10003);			pgrad._yscale = 3*maxl;			pgrad.setMask(pgmask);						pgmask2 = pages.attachMovie("pgmask","pgmask2",10004);			pgmask2._width = 2*pw;			pgmask2._height = ph;			p3shadow = pages.attachMovie("p3shadow","p3shadow",10005);			p3shadow._height = 3*maxl;			p3shadow.setMask(pgmask2);						pages.mask0._visible = false;			pages.mask1._visible = false;			pages.fgrad._visible = false;			pages.pgrad._visible = false;			pages.p3shadow._visible = false;						//set mask size			pages.mask0.maskbody._width = pages.mask1.maskbody._width = maxl;			pages.mask0.maskbody._height = pages.mask1.maskbody._height = 2*maxl;		}				function flipend() {			pp2.setMask(null);			pp3.setMask(null);			pages.fgrad._visible = false;			pages.pgrad._visible = false;			pages.p3shadow._visible = false;			//hardflip variables reset.			hflipend(hp2);			hflipend(hp3);		}				function hflipend(j) {			j.ph.pic.pic._x = 0;			j.ph.pic._rotation = 0;			j.ph.pic._xscale = 100;			j.ph.pic._yscale = 100;			j.ph._rotation = 0;			j.ph._xscale = 100;			j._yscale = 100;			j._x = 0;			j._y = 0;			j._visible = true;		}		function resetpage(i) {				//reset page position			p[pageNumber[i]].page._y = -ph/2;				}				function loadPage(i) {				//loading (creating a page)			if(p[i].mode == 0) {			//import page data from the Library				p[i].page = p[i].loadTo.attachMovie(p[i].name,"pic",0);				resetpage(i);								p[i].pLoaded = true;		//next page can be loaded immedietly				p[i].loading = false;		//no need for waiting the load progress				p[pLoad].item._visible = false;	//default not visible				return true;				//initialize the page container			}			if(p[i].mode == 1) {			//load external page data 				p[i].page = p[i].loadTo.attachMovie("empty","pic",0);				p[i].page.loadMovie(p[i].name);				resetpage(i);				//initialize the page container								p[i].pLoaded = false;		//page is not yet loaded				p[i].loading = true;		//watch load progress				return false;			}		}		//---------------------------------------------------------------------------------//This part of code runs first!pages._visible = false;setting_xml = new XML();				//XML flie loadingsetting_xml.onLoad = XMLparser;setting_xml.load(XMLfn);setting_xml.ignoreWhite = true;//-------------------------		function XMLparser(success) {						if (success == true) {				//XML file is successfully loaded, let's process data				var rootNode = setting_xml.firstChild;				var cnt = rootNode.childNodes.length;				var currentNode = rootNode.firstChild;								XML_TOCpage = 0;				XML_TOCs = new Array();								for(var i=0;i<cnt;i++) {							switch(currentNode.nodeName) {						case "Settings":							XMLgetSettings(currentNode);							break;						case "PageOrder":							XMLgetPageOrder(currentNode);							break;						case "Language":							XML_getLanguage(currentNode);							break;					}					currentNode = currentNode.nextSibling;				}				//Continue book building				CreatePageflip();							} else {										//Error - Nothing loaded				ctrl.loadertxt = "XML ERROR: CAN'T LOAD XML!";			}			delete setting_xml;		//delete temporary XML data		}				function XMLgetSettings(cNode) {							pw = 				XML_Number(		cNode.attributes.PageWidth,					300);			ph = 				XML_Number(		cNode.attributes.PageHeight,				400);			hcover = 			XML_Boolean(	cNode.attributes.Hardcover,					false);			hardpage = 			XML_Boolean(	cNode.attributes.Hardpage,					false);			EmbossedPages = 	XML_Boolean(	cNode.attributes.EmbossedPages,				true);			rotz = 				XML_Number(		cNode.attributes.HcoverAngle,				-30); //-15;	//hardflip max y difference			clickarea = 		XML_Number(		cNode.attributes.ClickArea,					64);			afa = 				XML_Number(		cNode.attributes.AutoFlipArea,				56);			gs = 				XML_Number(		cNode.attributes.GotoPageSpeed,				2);			ps = 				XML_Number(		cNode.attributes.MouseFollowSpeed,			5);			es = 				XML_Number(		cNode.attributes.OnReleaseSpeed,			3);			tlimit = 			XML_Number(		cNode.attributes.TearDistance,				80); //80;		//tear distance			canflip = 			XML_Boolean(	cNode.attributes.FlippingEnabled,			true);			transparency = 		XML_Boolean(	cNode.attributes.TransparencyEnabled,		false);			transparencyAct =	XML_Boolean(	cNode.attributes.TransparencyActivePage,	false);									BackFile = 			XML_String(		cNode.attributes.BackFile,					undefined);			BackActive = 		XML_Boolean(	cNode.attributes.BackActive,				false);			BackAlwaysVisible = XML_Boolean(	cNode.attributes.BackAlwaysVisible,			false);			BackContentFixed =	XML_Boolean(	cNode.attributes.BackContentFixed,			false);						BackgroundColor =	XML_Number(		cNode.attributes.BackgroundColor,			-1);			if(BackgroundColor==-1) BackgroundColor = undefined;			loadermc.setBackground(BackgroundColor);						buttonColor =		XML_Number(		cNode.attributes.buttonColor,				0x333333);			buttonOverColor =	XML_Number(		cNode.attributes.buttonOverColor,			0xF0B400);			buttonPressColor =	XML_Number(		cNode.attributes.buttonPressColor,			0x333333);			ctrl.btnCol = buttonColor;			ctrl.btnSelCol = buttonOverColor;			ctrl.btnPressCol = buttonPressColor;			ctrl.setColor();						mousehdl = 			XML_Boolean(	cNode.attributes.MouseControl,				true);						coverTop = 		0;			coverSide =		0;			coverBottom =	0;									startPage = 		XML_Number(		cNode.attributes.StartPage,					1);						AlwaysOpened =		XML_Boolean(	cNode.attributes.AlwaysOpened,				false);			if(AlwaysOpened && startPage<2) startPage=2;						CenterSinglePage =	XML_Boolean(	cNode.attributes.CenterSinglePage,			false);						pageAutoSize =		XML_Boolean(	cNode.attributes.AutoSize,					true);			UnloadPages =		XML_Boolean(	cNode.attributes.UnloadPages,				false);			startAF =			XML_Boolean(	cNode.attributes.startAutoFlip,				false);			AFInterval =		XML_Number( 	cNode.attributes.AutoFlipDefaultInterval,	2);			AFLoop =			XML_Boolean( 	cNode.attributes.AutoFlipLooping,			false);			PageCache =			XML_Number(		cNode.attributes.PageCache,					5);			//page loading on demand			RightToLeft =		XML_Boolean( 	cNode.attributes.RightToLeft,				false);			VerticalMode =		XML_Boolean( 	cNode.attributes.VerticalMode,				false);			if(VerticalMode) {				var temp = ph;				ph = pw;				pw = temp;			}						OffsetX =			XML_Number( 	cNode.attributes.OffsetX,					0);			OffsetY =			XML_Number( 	cNode.attributes.OffsetY,					0);						PageScale =			XML_Boolean( 	cNode.attributes.PageScale,					false);			if(PageScale) loadermc.resizeStage();			MaxScale =			XML_Number( 	cNode.attributes.MaxScale,					200);			BaseStageWidth =	XML_Number( 	cNode.attributes.BaseStageWidth,			Stage.width);			BaseStageHeight =	XML_Number( 	cNode.attributes.BaseStageHeight,			Stage.height);			_root.BaseStageWidth = BaseStageWidth;			_root.BaseStageHeight = BaseStageHeight;									PageLoaderBackColor = XML_Number(	cNode.attributes.PageLoaderBackColor,		0x000000);			PageLoaderColor = 	XML_Number(		cNode.attributes.PageLoaderColor,			0x000000);						PDFlink =			XML_String(		cNode.attributes.PDFlink,					undefined);			if(PDFlink!=undefined) ctrl.enablepdfbtn();						FullScreenEnabled = XML_Boolean( 	cNode.attributes.FullScreenEnabled,			true);			if(FullScreenEnabled) ctrl.enablefullscreenbtn();					ButtonHelp =		XML_Boolean(	cNode.attributes.ButtonHelp,				true);						LogoURL =			XML_String(		cNode.attributes.LogoURL,					undefined);			LogoLink =			XML_String(		cNode.attributes.LogoURL,					undefined);			zoomfs = 			XML_Number(		cNode.attributes.ZoomFollowSpeed,			5);			zoomAct = 			XML_Boolean(	cNode.attributes.ZoomActivePage,			false);			ZoomOnPageClick = 	XML_Boolean(	cNode.attributes.ZoomOnPageClick,			false);			LightBoxZoom = 		XML_Boolean(	cNode.attributes.LightBoxZoom,				false);			DragZoom =			XML_Boolean(	cNode.attributes.DragZoom,					false);			ZoomToTop =			XML_Boolean(	cNode.attributes.ZoomToTop,					false);			zoomHotspot =		XML_Boolean(	cNode.attributes.ZoomHotspot, 				true);			thEnabled =			XML_Boolean(	cNode.attributes.ThumbnailsEnabled,			true);						LiveThumbnails = 	XML_Boolean(	cNode.attributes.LiveThumbnails,			true);			ThumbnailWidth = 	XML_Number(		cNode.attributes.ThumbnailWidth,			0);			ThumbnailHeight = 	XML_Number(		cNode.attributes.ThumbnailHeight,			0);			thPadding = 		XML_Number(		cNode.attributes.ThumbnailPadding,			16);			thBorder = 			XML_Number(		cNode.attributes.ThumbnailBorderWidth,		0.5);			thBorderColor = 	XML_Number(		cNode.attributes.ThumbnailBorderColor,		0x000000);			thBorderHColor = 	XML_Number(		cNode.attributes.ThumbnailBorderHoverColor,	0x000000);						var cnt = cNode.childNodes.length;			if(cnt) {				var subNode = cNode.firstChild;				for(var i=0;i<cnt;i++) {					subNode = subNode.nextSibling;				}			}		}						function XMLgetPageOrder(cNode) {					XML_pageOrder = new Array();			XML_zoomname = new Array();			XML_caption = new Array();			XML_printname = new Array();			XML_thFiles = new Array();			XML_pageTear = new Array();			XML_pageLabels = new Array();			XML_pageName = new Array();			XML_isHard = new Array();			XML_hotspotData = new Array();			XML_data = new Array();			XML_label = new Array();			XML_page = 0;						var subNode = cNode.firstChild;			var cnt = cNode.childNodes.length;			if(cnt) {				for(var i=0;i<cnt;i++) {					if(subNode.nodeName=="PageData") 					{						XML_page++;						XML_pageOrder[XML_page]		= 	XML_String(		subNode.attributes.PageFile			);						XML_zoomname[XML_page]		= 	XML_String(		subNode.attributes.ZoomFile,		"");						XML_printname[XML_page]		= 	XML_String(		subNode.attributes.PrintFile,		"");						var largefile			    = 	XML_String(		subNode.attributes.LargeFile,		"");						if(largefile) XML_zoomname[XML_page] = XML_printname[XML_page] = largefile;						XML_caption[XML_page]		= 	XML_String(		subNode.attributes.Caption,			"");						XML_pageTear[XML_page]		=	XML_Boolean(	subNode.attributes.TearOff,			false);						XML_isHard[XML_page]		=	XML_Boolean(	subNode.attributes.HardPage,		false);						XML_pageName[XML_page]		= 	XML_String(		subNode.attributes.PageName,		undefined);						XML_thFiles[XML_page]		= 	XML_String(		subNode.attributes.ThumbnailFile	);						XML_hotspotData[XML_page]	=	XML_String(		subNode.attributes.HotspotData, 	"");						XML_data[XML_page]			= 	XML_String(		subNode.attributes.Data,			"");						XML_label[XML_page]			= 	XML_String(		subNode.attributes.Label,			undefined);					}					subNode = subNode.nextSibling;				}				maxpage = XML_page;			}		}				function XML_getLanguage(cNode) {			SoundLoadingText =					XML_String(		cNode.attributes.SoundLoadingText,					"Loading sounds #");			ZoomLoadingText =					XML_String(		cNode.attributes.ZoomLoadingText,					"Loading zoom page #");			PrintLoadingText =					XML_String(		cNode.attributes.PrintLoadingText,					"Loading print page #");				PreviousPageButtonHelp =			XML_String(		cNode.attributes.PreviousPageButtonHelp,			"Flip backward 1 page");			NextPageButtonHelp =				XML_String(		cNode.attributes.NextPageButtonHelp,				"Flip forward 1 page");			ZoomLeftButtonHelp =				XML_String(		cNode.attributes.ZoomLeftButtonHelp,				"Zoom left side page");			ZoomRightButtonHelp =				XML_String(		cNode.attributes.ZoomRightButtonHelp,				"Zoom right side page");			PrintLeftButtonHelp =				XML_String(		cNode.attributes.PrintLeftButtonHelp,				"Print left side page");			PrintRightButtonHelp =				XML_String(		cNode.attributes.PrintRightButtonHelp,				"Print right side page");			ThumbnailButtonHelp =				XML_String(		cNode.attributes.ThumbnailButtonHelp,				"Thumbnail view");			FullScreenOnButtonHelp =			XML_String(		cNode.attributes.FullScreenOnButtonHelp,			"Exit fullscreen mode")			FullScreenOffButtonHelp =			XML_String(		cNode.attributes.FullScreenOffButtonHelp,			"Switch to fullscreen mode")			PDFButtonHelp =						XML_String(		cNode.attributes.PDFButtonHelp,						"Download this book in pdf format");			StartAutoFlipHelp =					XML_String(		cNode.attributes.StartAutoFlipHelp,					"Start auto flipping");			StopAutoFlipHelp =					XML_String(		cNode.attributes.StopAutoFlipHelp,					"Stop auto flipping");							PagerText =							XML_String(		cNode.attributes.PagerText,							"Page #");  			ZoomPagerText =						XML_String(		cNode.attributes.ZoomPagerText,						"Zoom page #");			ThumbnailPagerSingle =				XML_String(		cNode.attributes.ThumbnailPagerSingle,				"Thumbnails");			ThumbnailPager =					XML_String(		cNode.attributes.ThumbnailPager,					"Thumbs #");			ThumbnailPreviousPageButtonHelp =	XML_String(		cNode.attributes.ThumbnailPreviousPageButtonHelp,	"Previous page");			ThumbnailNextPageButtonHelp =		XML_String(		cNode.attributes.ThumbnailNextPageButtonHelp,		"Next page");			CopyrightText =						XML_String(		cNode.attributes.CopyrightText,						"");						ctrl.credits.creditsin.htmlText = CopyrightText;		}				//parsing variables by type 		function XML_Boolean(att,def) {			if(def!=undefined && att==null) {				return def;			}			if(att=="true") return true;			else return false;		}				function XML_Number(att,def) {			if(def!=undefined && att==null) {				return def;			}			return Number(att);		}				function XML_String(att,def) {			if(def!=undefined && att==null) {				return def;			}			if(att==undefined) return undefined;			return String(att);		}				function XML_lang(str, ins) {			if(ins != undefined) {				var strparts = str.split("#")				return strparts[0]+ins+strparts[1];			} else {				return str;			}		}		var firstStart:Boolean = False;		function firstStartPF() {			firstStart = true;			reset(maxpage);			startPF();		//here starts the PF!		}		function startPF() {		//start the pageflip engine			pages._rotation = VerticalMode? 90: 0;			if(!firstStart) resetPages();						if(mousehdl) Mouse.addListener(mousecontroll);			ctrl.enablethumbsbtn();			ctrl.enableautoflipbtn();			ctrl.enablepagerin();			ctrl.setloader(0);			ctrl.setpager();			onEnterFrame = function() 			{	//Master onEnterFrame function				oef();		//main function: handles page turning -------------				if(canloadpages && pagesready) {					canloadpages = false;					resetPages();					firstStart = false;					startPageLoading();					pages._visible = true;				}			}			gotoAndStop("start");		}		// Pageflip creation ----------------------------------------------------------		function CreatePageflip() 		{				//Creates a working, self loading pageFlip			pagesready = false;			if(XML_page==undefined || XML_page<1) {		//If no pages were defined, don't start at all				XML_page = maxpage = 0;				ctrl.loadertxt = "XML ERROR: NO PAGES TO LOAD!";				return;			}			CreatePages();						//if loaded -> go to create pages			setShadows();			if(directlink>0 && directlink<=gmaxpage) {				startPage = directlink;			}			if(RightToLeft) startPage = maxpage-startPage+1;	//gmaxpage???			page = Math.floor(startPage/2)*2;	//first page (normally it is 0 = the page before the cover = blank page)			canloadpages = true;				//let's load the content						firstStartPF();		}		function CreatePages() 		{			//Create the page objects of the book			p = new Array();				//define page content			gminpage = AlwaysOpened?2:1;	//set the first visible page depending on the book style AlwaysOpened			maxpage = XML_page+gminpage-1;	//set also the last page depending on it			gmaxpage = maxpage;				//last visible page			maxpage += maxpage%2;			//set maxpage for later calculations						if(RightToLeft) {				//if the book is in RTL mode, we have to recalculate our variables				if(gmaxpage%2==1) {					if(gminpage==1) i = maxpage, gminpage = 2;					else i = maxpage-1, gminpage = 2, gmaxpage-=1;				} else {					if(gminpage==1) i = maxpage;					else i = maxpage-1, gminpage = 1, gmaxpage-=1;				}			} else i = gminpage;			pNum = 1;	//page numbering start, can be overwritten from xml: pageName="*5" -> will start page numbering from 5;						for(var j=1; j<=gmaxpage ;j++) {				var isCover = (i<3) || (i>maxpage-2);				p[i] = pageData(i, XML_pageOrder[j], XML_zoomname[j], XML_caption[j], XML_printname[j], XML_pageName[j], XML_thFiles[j], XML_pageTear[j], XML_isHard[j], XML_hotspotData[j], XML_data[j], XML_label[j], isCover);				i += RightToLeft? -1: 1;				pNum++;			}					}				function pageData(i, name, zoomname, caption, printname, pageName, thFile, tear, isHard, hotspot, data, label, isCover) {				var obj = new Object();						obj.no = i;			obj.name = name;			obj.zoomname = zoomname;			obj.caption = caption;			obj.printname = printname;			obj.tear = tear;			obj.hotspot = hotspot;			obj.data = data;			obj.label = label;			obj.isCover = isCover;			obj.isHard = isHard;						if(pageName!=undefined) {				if(pageName.charAt(0)=="*") {					var n = Number(pageName.substr(1));					pNum = isNaN(n) ? 1: n;					obj.pageNumber = pNum;				} else obj.pageName = pageName;			} else obj.pageNumber = pNum;						obj.thFile = thFile;						obj.pLoaded = false;			obj.loading = false;						obj.item = pages.attachMovie("mainpage","p"+i,i);			obj.item._x = (i%2==0)? 0: pw;			obj.item.page._x = -pw;									obj.loadTo = obj.item.page.pf.sph.ph.pic;							obj.page = obj.loadTo.attachMovie("pageContainer","pic",0);			obj.page._y = -ph/2;			obj.page.no = i;			obj.page.name = name;			obj.page.zoomname = zoomname;			obj.page.caption = caption;			obj.page.printname = printname;			obj.page.hotspot = hotspot;			obj.page.data = data;			obj.page.label = label;			obj.page.isCover = isCover;			obj.page.isHard = isHard;			obj.page.pageName = obj.pageName;			obj.page.pageNumber = obj.pageNumber;			obj.page.thFile = thFile;						obj.item._visible = false;	//default not visible						return obj;		}//page loading on demand -------------------------------------------------------		var lploading:Boolean = false;var lpage:Number = -1;var lpdcnt:Number = 0;var lpucnt:Number = 1;var unloading:Boolean = false;				//loads page content from actual page +/- pageCache		function startPageLoading() 		{					var i:Number = page-page%2;			lpage = i;			lpdcnt = 0;			lpucnt = 0;			unloading = false;			if(!lploading) {				//do nothing if already loading				lploading = true;				loadNextPage();			}		}		function loadNextPage() 		{			//load the next page				var loading = false;			while(!loading) {				var i:Number = getnext();				if(!p[pageNumber[i]].pLoaded || unloading) {					if(i>=gminpage && i<=gmaxpage) {		//gmaxpage?						if(!unloading) {							loading = p[pageNumber[i]].page.loadPage(true);						} else {							if(!((i==2 || i==maxpage-1))) p[pageNumber[i]].page.unloadPage();						}					} else lploading = false, loading = true;				}			}		}				function getnext() 		{				//find the next page to load			var np:Number = -1;			while (np<0) {				if(lpdcnt>lpucnt) {					lpucnt++;					if(lpage+lpucnt<=gmaxpage) np = lpage+lpucnt;				} else {					var cnt = lpdcnt;					lpdcnt++;					if(cnt>=PageCache) unloading=true;					if(cnt>gmaxpage) np = 0;					if(lpage-cnt>=gminpage) np = lpage-cnt;				}			}			return np;		}